//
// Created by 谭文波 on 2019/11/30.
//

#define GLUT_DISABLE_ATEXIT_HACK

#include <vertex.h>

extern vector<AddTriangle> McTri;

//These tables are used so that everything can be done in little loops that you can look at all at once
// rather than in pages and pages of unrolled code.

//a2fVertexOffset lists the positions, relative to vertex0, of each of the 8 vertices of a cube      立方体8个顶点
//  立方体8个顶点
static  GLfloat a2fVertexOffset[8][3] =
        {
                {0.0, 0.0, 0.0},{1.0, 0.0, 0.0},{1.0, 1.0, 0.0},{0.0, 1.0, 0.0},
                {0.0, 0.0, 1.0},{1.0, 0.0, 1.0},{1.0, 1.0, 1.0},{0.0, 1.0, 1.0}
        };

//a2iEdgeConnection lists the index of the endpoint vertices for each of the 12 edges of the cube    立方体12个边
static const GLint a2iEdgeConnection[12][2] =
        {
                {0,1}, {1,2}, {2,3}, {3,0},
                {4,5}, {5,6}, {6,7}, {7,4},
                {0,4}, {1,5}, {2,6}, {3,7}
        };

//a2fEdgeDirection lists the direction vector (vertex1-vertex0) for each edge in the cube    立方体 12个边的方向向量
static const GLfloat a2fEdgeDirection[12][3] =
        {
                {1.0, 0.0, 0.0},{0.0, 1.0, 0.0},{-1.0, 0.0, 0.0},{0.0, -1.0, 0.0},
                {1.0, 0.0, 0.0},{0.0, 1.0, 0.0},{-1.0, 0.0, 0.0},{0.0, -1.0, 0.0},
                {0.0, 0.0, 1.0},{0.0, 0.0, 1.0},{ 0.0, 0.0, 1.0},{0.0,  0.0, 1.0}
        };

// For any edge, if one vertex is inside of the surface and the other is outside of the surface
//  then the edge intersects the surface
// For each of the 8 vertices of the cube can be two possible states : either inside or outside of the surface
// For any cube the are 2^8=256 possible sets of vertex states
// This table lists the edges intersected by the surface for all 256 possible vertex states
// There are 12 edges.  For each entry in the table, if edge #n is intersected, then bit #n is set to 1
//对于每一条边,如果一个顶点在边界内而另一个顶点在边界外，那么这条边和边界肯定有交点
// 对于立方体的8个顶点有两种情况: 要么在边界内，要么在边界外,对每个立方体的8个顶点有2^8=256种情况
static GLint aiCubeEdgeFlags[256]=
        {
                0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
                0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
                0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
                0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
                0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
                0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
                0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
                0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
                0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
                0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
                0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
                0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460,
                0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0,
                0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230,
                0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190,
                0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x000
        };

//  For each of the possible vertex states listed in aiCubeEdgeFlags there is a specific triangulation
//  of the edge intersection points.  a2iTriangleConnectionTable lists all of them in the form of
//  0-5 edge triples with the list terminated by the invalid value -1.
//  For example: a2iTriangleConnectionTable[3] list the 2 triangles formed when corner[0]
//  and corner[1] are inside of the surface, but the rest of the cube is not.
//  I found this table in an example program someone wrote long ago.  It was probably generated by hand

static GLint a2iTriangleConnectionTable[256][16] =
        {
                {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
                {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
                {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
                {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
                {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
                {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
                {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
                {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
                {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
                {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
                {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
                {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
                {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
                {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
                {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
                {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
                {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
                {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
                {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
                {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
                {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
                {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
                {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
                {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
                {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
                {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
                {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
                {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
                {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
                {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
                {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
                {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
                {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
                {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
                {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
                {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
                {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
                {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
                {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
                {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
                {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
                {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
                {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
                {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
                {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
                {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
                {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
                {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
                {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
                {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
                {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
                {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
                {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
                {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
                {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
                {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
                {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
                {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
                {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
                {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
                {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
                {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
                {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
                {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
                {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
                {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
                {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
                {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
                {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
                {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
                {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
                {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
                {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
                {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
                {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
                {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
                {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
                {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
                {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
                {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
                {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
                {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
                {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
                {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
                {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
                {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
                {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
                {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
                {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
                {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
                {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
                {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
                {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
                {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
                {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
                {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
                {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
                {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
                {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
                {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
                {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
                {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
                {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
                {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
                {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
                {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
                {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
                {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
                {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
                {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
                {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
                {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
                {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
                {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
                {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
                {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
                {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
                {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
                {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
                {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
                {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
                {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
                {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
                {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
                {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
                {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
                {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
                {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
                {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
                {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
                {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
                {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
                {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
                {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
                {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
                {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
                {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
                {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
                {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
                {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
                {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
                {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
                {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
                {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
                {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
                {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
                {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
                {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
                {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
                {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
                {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
                {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
                {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
                {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
                {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
                {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
                {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
                {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
                {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
                {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
                {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
                {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
                {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
                {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
                {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
                {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
                {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
                {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
                {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
                {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
                {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
                {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
                {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
                {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
                {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
                {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
                {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
                {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
                {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
                {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
                {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
                {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
                {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
                {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
                {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
                {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
                {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
                {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
                {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
        };

static const GLfloat afAmbientWhite [] = {0.25, 0.25, 0.25, 1.00};   // 周围 环绕 白
static const GLfloat afAmbientRed   [] = {0.25, 0.00, 0.00, 1.00};   // 周围 环绕 红
static const GLfloat afAmbientGreen [] = {0.00, 0.25, 0.00, 1.00};   // 周围 环绕 绿
static const GLfloat afAmbientBlue  [] = {0.00, 0.00, 0.25, 1.00};   // 周围 环绕 蓝
static const GLfloat afDiffuseWhite [] = {0.75, 0.75, 0.75, 1.00};   // 漫射 白
static const GLfloat afDiffuseRed   [] = {0.75, 0.00, 0.00, 1.00};   // 漫射 红
static const GLfloat afDiffuseGreen [] = {0.00, 0.75, 0.00, 1.00};   // 漫射 绿
static const GLfloat afDiffuseBlue  [] = {0.00, 0.00, 0.75, 1.00};   // 漫射 蓝
static const GLfloat afSpecularWhite[] = {1.00, 1.00, 1.00, 1.00};   // 反射 白
static const GLfloat afSpecularRed  [] = {1.00, 0.25, 0.25, 1.00};   // 反射 红
static const GLfloat afSpecularGreen[] = {0.25, 1.00, 0.25, 1.00};   // 反射 绿
static const GLfloat afSpecularBlue [] = {0.25, 0.25, 1.00, 1.00};   // 反射 蓝


//GLenum    ePolygonMode = GL_FILL;

//目标值越小，三角面片越小
GLfloat  fTargetValue = 50.0;

#define NX 80
#define NY 80
#define NZ 80
//
//#define NX 48
//#define NY 62
//#define NZ 42

//short int data[10][10][10];
short int ***data;

short int themax = 0,themin = 255;


//向量
//struct GLvector
//{
//    float x;
//    float y;
//    float z;
//};


void readFile(){
    int i,j,k,c;
    short int isolevel = 150;

    FILE *fptr;
    std::cout << "begin read" << std::endl;

    // Malloc the volumetric data, hardwired size!
    data = (short int ***)malloc(NX*sizeof(short int **));
    for (i=0;i<NX;i++)
        data[i] = (short int **)malloc(NY*sizeof(short int *));
    for (i=0;i<NX;i++)
        for (j=0;j<NY;j++)
            data[i][j] = (short int *)malloc(NZ*sizeof(short int));

    // Open and read the raw data
    fprintf(stderr,"Reading data ...\n");
    if ((fptr = fopen("/Users/tanwenbo/CLionProjects/PaperProject/src/mri.raw","rb")) == nullptr) {
        fprintf(stderr,"File open failed\n");
        exit(-1);
    }
    //读入坐标
    // 这里封装一下就好了！但是搞不懂整个格式是怎么读入的
    for (k=0;k<NZ;k++) {
        for (j=0;j<NY;j++) {
            for (i=0;i<NX;i++) {
                if ((c = fgetc(fptr)) == EOF) {
                    fprintf(stderr,"Unexpected end of file\n");
                    exit(-1);
                }

//                std::cout << c << std::endl;
                data[i][j][k] = c;

                if (c > themax)
                    themax = c;
                if (c < themin)
                    themin = c;
            }
        }
    }
    fclose(fptr);
}
//int main(int argc, char **argv)
//{
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    int i,j,k,c;
//    short int isolevel = 150;
//
//    FILE *fptr;
//    argc=2;
//
//
//    argv[1]="C:\\Users\\HuangWang\\Desktop\\Head_256x256x256.raw";
//
//    for (i=1;i<argc;i++) {
//        if (strcmp(argv[i],"-i") == 0)
//            isolevel = atof(argv[i+1]);
//    }
//
//    // Malloc the volumetric data, hardwired size!
//    data = (short int ***)malloc(NX*sizeof(short int **));
//    for (i=0;i<NX;i++)
//        data[i] = (short int **)malloc(NY*sizeof(short int *));
//    for (i=0;i<NX;i++)
//        for (j=0;j<NY;j++)
//            data[i][j] = (short int *)malloc(NZ*sizeof(short int));
//
//    // Open and read the raw data
//    fprintf(stderr,"Reading data ...\n");
//    if ((fptr = fopen(argv[argc-1],"rb")) == NULL) {
//        fprintf(stderr,"File open failed\n");
//        exit(-1);
//    }
//    //读入坐标
//    // 这里封装一下就好了！但是搞不懂整个格式是怎么读入的
//    for (k=0;k<NZ;k++) {
//        for (j=0;j<NY;j++) {
//            for (i=0;i<NX;i++) {
//                if ((c = fgetc(fptr)) == EOF) {
//                    fprintf(stderr,"Unexpected end of file\n");
//                    exit(-1);
//                }
//
//                data[i][j][k] = c;
//
//这个themax看起来像是包围盒。
//                if (c > themax)
//                    themax = c;
//                if (c < themin)
//                    themin = c;
//            }
//        }
//    }
//    fclose(fptr);
//    fprintf(stderr,"Volumetric data range: %d -> %d\n",themin,themax);
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    GLfloat afPropertiesAmbient [] = {0.25, 0.25, 0.25, 1.00};
//    GLfloat afPropertiesDiffuse [] = {0.75, 0.75, 0.75, 1.00};
//    GLfloat afPropertiesSpecular[] = {1.00, 0.25, 0.25, 1.00};
//
//
//    glClearColor( 0.0, 0.0, 0.0, 1.0 );
//    glClearDepth( 1.0 );
//
//    glEnable(GL_DEPTH_TEST);
//    glEnable(GL_LIGHTING);
//    glPolygonMode(GL_FRONT_AND_BACK, ePolygonMode);
//
//    glLightfv( GL_LIGHT0, GL_AMBIENT,  afPropertiesAmbient);
//    glLightfv( GL_LIGHT0, GL_DIFFUSE,  afPropertiesDiffuse);
//    glLightfv( GL_LIGHT0, GL_SPECULAR, afPropertiesSpecular);
//    glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 1.0);
//
//    glEnable( GL_LIGHT0 );
//
//    // 材质颜色  ***里外 ***
//    glMaterialfv(GL_BACK,  GL_AMBIENT,   afAmbientRed);
//    glMaterialfv(GL_BACK,  GL_DIFFUSE,   afDiffuseRed);
//    glMaterialfv(GL_FRONT, GL_AMBIENT,   afAmbientWhite);
//    glMaterialfv(GL_FRONT, GL_DIFFUSE,   afDiffuseWhite);
//    glMaterialfv(GL_FRONT, GL_SPECULAR,  afSpecularWhite);
//    glMaterialf( GL_FRONT, GL_SHININESS, 10.0);
//
//    vResize(iWidth, iHeight);
//
//    vPrintHelp();
//    glutMainLoop();
//}
//
//// 帮助内容
//GLvoid vPrintHelp()
//{
//    printf("Marching Cubes Rountines by Niu Kenan (niukenan@sina.com)\n\n");
//}
//
//// 窗口改变响应
//void vResize( GLsizei iWidth, GLsizei iHeight )
//{
//    GLfloat fAspect, fHalfWorldSize = (1.4142135623730950488016887242097/2);
//    glViewport( 0, 0, iWidth, iHeight );
//    glMatrixMode (GL_PROJECTION);
//    glLoadIdentity ();
//
//    if(iWidth <= iHeight)
//    {
//        fAspect = (GLfloat)iHeight / (GLfloat)iWidth;
//        glOrtho(-fHalfWorldSize*ZoonAspect, fHalfWorldSize*ZoonAspect, -fHalfWorldSize*fAspect*ZoonAspect,
//                fHalfWorldSize*fAspect*ZoonAspect, -10*fHalfWorldSize*ZoonAspect, 10*fHalfWorldSize*ZoonAspect);
//
//    }
//    else
//    {
//        fAspect = (GLfloat)iWidth / (GLfloat)iHeight;
//        glOrtho(-fHalfWorldSize*fAspect*ZoonAspect, fHalfWorldSize*fAspect*ZoonAspect, -fHalfWorldSize*ZoonAspect,
//                fHalfWorldSize*ZoonAspect, -10*fHalfWorldSize*ZoonAspect, 10*fHalfWorldSize*ZoonAspect);
//
//    }
//    glMatrixMode( GL_MODELVIEW );
//
//}
//
//void spinDisplay(void)
//{
//    HoriRotate = HoriRotate+10.0;
//    if (HoriRotate >360.0)
//        HoriRotate = HoriRotate -360.0;
//    glutPostRedisplay();
//}
//void yawDisplay(void)
//{
//    VertiRotate = VertiRotate+10.0;
//    if (VertiRotate >360.0)
//        VertiRotate = VertiRotate -360.0;
//    glutPostRedisplay();
//
//}
//
//// 鼠标响应
//void myMouseCall(int button, int state, int x ,int y)
//{
//    switch (button)
//    {
//        case GLUT_LEFT_BUTTON:
//            if (state == GLUT_DOWN)
//                spinDisplay();
//            break;
//
//
//        case GLUT_RIGHT_BUTTON:
//            if(state == GLUT_DOWN)
//                yawDisplay();
//            break;
//
//        case GLUT_WHEEL_UP:
//
//            ZoomScale=ZoomScale+0.05;
//            glutPostRedisplay();
//            break;
//
//        case GLUT_WHEEL_DOWN:
//            ZoomScale=ZoomScale-0.05;
//            glutPostRedisplay();
//
//            break;
//
//
//        default:
//            break;
//    }
//}
//
//// 键盘响应
//void vKeyboard(unsigned char cKey, int iX, int iY)
//{
//    switch(cKey)
//    {
//        case 'w' :
//        {
//            if(ePolygonMode == GL_LINE)
//            {
//                ePolygonMode = GL_FILL;
//                glutPostRedisplay();
//            }
//            else
//            {
//                ePolygonMode = GL_LINE;
//                glutPostRedisplay();
//            }
//            glPolygonMode(GL_FRONT_AND_BACK, ePolygonMode);
//        } break;
//
//
//        case 'l' :
//        {
//            if(bLight)
//            {
//                glDisable(GL_LIGHTING);//use vertex colors
//                glutPostRedisplay();
//            }
//            else
//            {
//                glEnable(GL_LIGHTING);//use lit material color
//                glutPostRedisplay();
//            }
//
//            bLight = !bLight;
//        };
//    }
//}
//
////特殊键响应 上下左右 PaUP PaDn
//void vSpecial(int iKey, int iX, int iY)
//{
//    switch(iKey)
//    {
//        case GLUT_KEY_F1 :
//        {
//            ZoonAspect-=10;
//            glutReshapeFunc( vResize );
//
//        } break;
//
//
//            ////////////////////////////////////////////
//        case GLUT_KEY_PAGE_UP :
//        {
//            if(fTargetValue<=themax-1)
//            {
//                fTargetValue=fTargetValue+1;
//            }
//            else
//            {
//                fTargetValue=themax;
//            }
//            glutPostRedisplay();
//
//
//        } break;
//        case GLUT_KEY_PAGE_DOWN :
//        {
//            if(fTargetValue>=themin+1)
//            {
//                fTargetValue=fTargetValue-1;
//            }
//            else
//            {
//                fTargetValue=themin;
//            }
//            glutPostRedisplay();
//
//        } break;
//////////////////////////////////////////////////////////////////////////////
//
//
////***                     键盘 上下左右 控制               ***//
/////////////////////////////////////////////////////////////////////////
//        case GLUT_KEY_UP :    // 上
//        {
//            Ytranform+=10.0;
//            glutPostRedisplay();
//        } break;
//
//        case GLUT_KEY_DOWN :   // 下
//        {
//            Ytranform-=10.0;
//            glutPostRedisplay();
//        } break;
//
//        case GLUT_KEY_LEFT :    // 左
//        {
//            Xtranform-=10.0;
//            glutPostRedisplay();
//        } break;
//
//        case GLUT_KEY_RIGHT :   //  右
//        {
//            Xtranform+=10.0;
//            glutPostRedisplay();
//        } break;
///////////////////////////////////////////////////////////////////////////
//    }
//}
//
//
//void vIdle()//   程序空闲时
//{
//    // 重绘函数
//    //glutPostRedisplay();
//
//}
//
//int i=0;
//void vDrawScene() // 绘制场景
//{
//    i=i+1;
//    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
//
//    glPushMatrix();
//
//    glTranslatef(Xtranform, Ytranform, Ztranform);
//    /*printf("%f,  %f,  %f \n" ,Xtranform, Ytranform, Ztranform );
//    printf("%f,  %f \n" ,VertiRotate, HoriRotate);*/
//    glRotatef(     HoriRotate, 1.0, 0.0, 0.0);
//    glRotatef(     0.0, 0.0, 1.0, 0.0);
//    glRotatef(     VertiRotate, 0.0, 0.0, 1.0);
//
//    glScaled(ZoomScale,ZoomScale,ZoomScale);
//    if (i==1)
//    {
//        marchingCube=glGenLists(1);
//        glNewList(marchingCube,GL_COMPILE);
//
//        vMarchingCubes();
//        glEndList();
//        glCallList(marchingCube);
//    }
//    else if(i>1)
//    {
//        glCallList(marchingCube);
//    }
//
//    glPushAttrib(GL_LIGHTING_BIT);
//    glDisable(GL_LIGHTING);
//    /* glColor3f(1.0, 1.0, 1.0);
//     glutWireCube(100.0); */
//    glPopAttrib();
//
//
//
//
//
//    glPopMatrix();
//
////    glutSwapBuffers();
//}

//************************************************************************************************************************************************
/*                                                             Marching Cube 计算相关函数                                                       */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//fGetOffset finds the approximate point of intersection of the surface
// between two points with the values fValue1 and fValue2

VERTEX SourcePoint[3];


//数据场？
void SetSample(float NewTime)
{
    for(int i = 0; i < 3; i++)
    {
        SourcePoint[i].x = 0.5;
        SourcePoint[i].y = 0.5;
        SourcePoint[i].z = 0.5;
    }

    SourcePoint[0].x *= 1.0 + sinf(NewTime);
    SourcePoint[1].y *= 1.0 + sinf(NewTime);
    SourcePoint[2].z *= 1.0 + sinf(NewTime);
    std::cout << SourcePoint[0].x << " haha " << SourcePoint[1].y << " " << SourcePoint[2].z << std::endl;
}

//距离场
float Dist(GLfloat x, GLfloat y, GLfloat z)
{
    double Result = 0.0;
    double Dx, Dy, Dz;
    Dx = x - SourcePoint[0].x;
    Dy = y - SourcePoint[0].y;
    Dz = z - SourcePoint[0].z;
    Result += 0.5/(Dx*Dx + Dy*Dy + Dz*Dz);


    Dx = x - SourcePoint[1].x;
    Dy = y - SourcePoint[1].y;
    Dz = z - SourcePoint[1].z;
    Result += 1.0/(Dx*Dx + Dy*Dy + Dz*Dz);


    Dx = x - SourcePoint[2].x;
    Dy = y - SourcePoint[2].y;
    Dz = z - SourcePoint[2].z;
    Result += 1.5/(Dx*Dx + Dy*Dy + Dz*Dz);


    return Result;
}


GLfloat fGetOffset(GLfloat fValue1, GLfloat fValue2, GLfloat fValueDesired)
{
    GLdouble fDelta = fValue2 - fValue1;

    if(fDelta == 0.0)
    {
        return 0.5;
    }
    return (fValueDesired - fValue1)/fDelta;
}

// 根据 位置 以及 法向量 产生颜色
GLvoid vGetColor(GLvector &rfColor, GLvector &rfPosition, GLvector &rfNormal)
{
    GLfloat x = rfNormal.x;
    GLfloat y = rfNormal.y;
    GLfloat z = rfNormal.z;
    rfColor.x = (x > 0.0 ? x : 0.0) + (y < 0.0 ? -0.5*y : 0.0) + (z < 0.0 ? -0.5*z : 0.0);
    rfColor.y = (y > 0.0 ? y : 0.0) + (z < 0.0 ? -0.5*z : 0.0) + (x < 0.0 ? -0.5*x : 0.0);
    rfColor.z = (z > 0.0 ? z : 0.0) + (x < 0.0 ? -0.5*x : 0.0) + (y < 0.0 ? -0.5*y : 0.0);
}

//向量标准化
GLvoid vNormalizeVector(GLvector &rfVectorResult, GLvector &rfVectorSource)
{
    GLfloat fOldLength;
    GLfloat fScale;

    fOldLength = sqrtf( (rfVectorSource.x * rfVectorSource.x) +
                        (rfVectorSource.y * rfVectorSource.y) +
                        (rfVectorSource.z * rfVectorSource.z) );

    if(fOldLength == 0.0)
    {
        rfVectorResult.x = rfVectorSource.x;
        rfVectorResult.y = rfVectorSource.y;
        rfVectorResult.z = rfVectorSource.z;
    }
    else
    {
        fScale = 1.0/fOldLength;
        rfVectorResult.x = rfVectorSource.x*fScale;
        rfVectorResult.y = rfVectorSource.y*fScale;
        rfVectorResult.z = rfVectorSource.z*fScale;
    }
}




//vGetNormal() finds the gradient of the scalar field at a point
//This gradient can be used as a very accurate vertx normal for lighting calculations
GLvoid vGetNormal(GLvector &rfNormal, GLfloat x, GLfloat y, GLfloat z)                   // 计算 数据场一点的梯度
{
    if (  x>1 && x<NX-1 &&    y>1 && y<NY-1  &&  z>1 && z<NZ-1    )
    {
        rfNormal.x = (GLfloat)data[(int)x-1][ (int)y][ (int)z] - (GLfloat)data[(int)x+1][ (int)y] [(int)z];
        rfNormal.y = (GLfloat)data[(int)x] [(int)y-1] [(int)z] - (GLfloat)data[(int)x][(int) y+1][(int)z];
        rfNormal.z = (GLfloat)data[(int)x][(int)y][(int) z-1] - (GLfloat)data[(int)x][ (int)y][ (int)z+1];
        vNormalizeVector(rfNormal, rfNormal);
    }
}

//vMarchCube1 performs the Marching Cubes algorithm on a single cube
GLvoid vMarchCube(GLfloat x, GLfloat y, GLfloat z, GLfloat fScale)                   // Marching Cubes 算法对于一个 单个立方体
{
//    extern GLint aiCubeEdgeFlags[256];
//    extern GLint a2iTriangleConnectionTable[256][16];

    GLint iCorner, iVertex, iVertexTest, iEdge, iTriangle, iFlagIndex, iEdgeFlags;
    GLfloat fOffset;
    GLvector sColor;
    GLfloat afCubeValue[8];
    GLvector asEdgeVertex[12];
    GLvector asEdgeNorm[12];

    //Make a local copy of the values at the cube's corners  保存 每一个Cube的八个顶点。


    //场函数计算？这个尼玛到底怎么算的，如果是球体也不是很对啊。真是日了他妈了。
    for(iVertex = 0; iVertex < 8; iVertex++)
    {
        //这个看起来是坐标？在这了变成强转了，所以导致这个数据看起来小了很多，产生了二义性？那么我输入的数据就是xyz这个坐标是否有值？
//        afCubeValue[iVertex] =(GLfloat)data[(int)(x + a2fVertexOffset[iVertex][0])]
////        [(int)(y + a2fVertexOffset[iVertex][1])]
////        [(int)(z + a2fVertexOffset[iVertex][2])] ;


        //offset是偏移量？
        afCubeValue[iVertex] = Dist(  x + a2fVertexOffset[iVertex][0]*fScale,
                                      y + a2fVertexOffset[iVertex][1]*fScale,
                                      z + a2fVertexOffset[iVertex][2]*fScale);
    }

    //Find which vertices are inside of the surface and which are outside   找出哪些顶点是在等值面内，哪些是在等值面外
    iFlagIndex = 0;

    //fTargetValue应该是立方体比例大小？
    //体素小于ftargetvalue就行。
    for(iVertexTest = 0; iVertexTest < 8; iVertexTest++)
    {
        if(afCubeValue[iVertexTest] <= fTargetValue)
            iFlagIndex |= 1<<iVertexTest;
    }

    //Find which edges are intersected by the surface  找到与等值面有交点的边
    iEdgeFlags = aiCubeEdgeFlags[iFlagIndex];

    //If the cube is entirely inside or outside of the surface, then there will be no intersections
    //如果整个立方体都在边界内，则没有交点
    if(iEdgeFlags == 0)
    {
        return;
    }
    //Find the point of intersection of the surface with each edge 找到每一个与等值面相交的边，并且找到等值面在这一点的法向量
    //Then find the normal to the surface at those points
    for(iEdge = 0; iEdge < 12; iEdge++)
    {
        //if there is an intersection on this edge 如果在这一个边上有交点的话
        if(iEdgeFlags & (1<<iEdge))
        {
            fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[iEdge][0] ],
                                 afCubeValue[ a2iEdgeConnection[iEdge][1] ], fTargetValue);

            //计算交点的坐标
            asEdgeVertex[iEdge].x = x + (a2fVertexOffset[ a2iEdgeConnection[iEdge][0] ][0]  +  fOffset * a2fEdgeDirection[iEdge][0])*fScale ;//* fScale;
            asEdgeVertex[iEdge].y = y + (a2fVertexOffset[ a2iEdgeConnection[iEdge][0] ][1]  +  fOffset * a2fEdgeDirection[iEdge][1]) *fScale;//* fScale;
            asEdgeVertex[iEdge].z = z + (a2fVertexOffset[ a2iEdgeConnection[iEdge][0] ][2]  +  fOffset * a2fEdgeDirection[iEdge][2]) *fScale;//* fScale;
            //计算交点的法向量
            vGetNormal(asEdgeNorm[iEdge], asEdgeVertex[iEdge].x, asEdgeVertex[iEdge].y, asEdgeVertex[iEdge].z);
        }
    }


    //Draw the triangles that were found.  There can be up to five per cube   画出等值面三角形 每个立方体 5个三角形
    for(iTriangle = 0; iTriangle < 5; iTriangle++)
    {
        if(a2iTriangleConnectionTable[iFlagIndex][3*iTriangle] < 0)
            break;

        //将这里的数据输入到三角里？
        AddTriangle mcTriangle;

        mcTriangle.a = asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][3*iTriangle]];
        mcTriangle.b = asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][3*iTriangle + 1]];
        mcTriangle.c = asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][3*iTriangle + 2]];

        McTri.push_back(mcTriangle);

//        for(iCorner = 0; iCorner < 3; iCorner++)
//        {
//            iVertex = a2iTriangleConnectionTable[iFlagIndex][3*iTriangle+iCorner];
//
//            vGetColor(sColor, asEdgeVertex[iVertex], asEdgeNorm[iVertex]);
//            //画出三角
//            glColor3f(sColor.x, sColor.y, sColor.z);
//            glNormal3f(asEdgeNorm[iVertex].x,   asEdgeNorm[iVertex].y,   asEdgeNorm[iVertex].z);
//            glVertex3f(asEdgeVertex[iVertex].x, asEdgeVertex[iVertex].y, asEdgeVertex[iVertex].z);
//        }
    }
}

//vMarchingCubes iterates over the entire dataset, calling vMarchCube on each cube

//这里画三角，然后数据如何保存起来？

//xyz到底尼玛是什么蛇皮数据？
GLvoid vMarchingCubes()
{

    int     DataSetSize = 16;

    for( int X = 0; X < DataSetSize; X++)
        for(int Y = 0; Y < DataSetSize; Y++)
            for(int Z = 0; Z < DataSetSize; Z++)
                vMarchCube(X*(1.0/DataSetSize), Y*(1.0/DataSetSize), Z*(1.0/DataSetSize), (1.0 / 16) );

    printf("finish one Draw ! !\n");
}

